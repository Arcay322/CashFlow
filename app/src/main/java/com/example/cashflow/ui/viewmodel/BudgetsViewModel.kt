package com.example.cashflow.ui.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.cashflow.data.Budget
import com.example.cashflow.data.BudgetRepository
import com.example.cashflow.data.Transaction
import com.example.cashflow.data.TransactionRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class BudgetsViewModel @Inject constructor(
    private val budgetRepository: BudgetRepository,
    private val transactionRepository: TransactionRepository
) : ViewModel() {

    private val _budgets = budgetRepository.getAllBudgets().stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5000),
        emptyList()
    )

    val budgetsWithSpending: StateFlow<List<BudgetWithSpending>> =
        _budgets.flatMapLatest { budgets ->
            if (budgets.isEmpty()) {
                flowOf(emptyList())
            } else {
                combine(budgets.map { budget ->
                    transactionRepository.getAllTransactions().map { transactions ->
                        val totalSpending = transactions
                            .filter { it.type == "Gasto" && it.category == budget.category }
                            .sumOf { it.amount }
                        BudgetWithSpending(budget, totalSpending)
                    }
                }) { budgetWithSpendingsArray ->
                    budgetWithSpendingsArray.toList()
                }
            }
        }.stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5000),
            emptyList()
        )

 val overallBudgetProgress: StateFlow<Float> = budgetsWithSpending.map { list ->
        if (list.isEmpty()) {
            0f
        } else {
            val totalBudgeted = list.sumOf { it.budget.amount }
            val totalSpent = list.sumOf { it.currentSpending }
            if (totalBudgeted > 0) (totalSpent / totalBudgeted).toFloat() else 0f
        }
    }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5000),
        0f
    )

 fun createBudget(budget: Budget) {
        viewModelScope.launch {
            budgetRepository.insertBudget(budget)
        }
    }

 fun deleteBudget(budget: Budget) {
        viewModelScope.launch {
            budgetRepository.deleteBudget(budget)
        }
    }

 data class BudgetWithSpending(
 val budget: Budget,
 val currentSpending: Double
 )



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































                        }
                }) { budgetWithSpendings ->
                    budgetWithSpendings.toList()
                }
            }
        }.stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5000),
            emptyList()
        )

    val overallBudgetProgress: StateFlow<Float> = budgetsWithSpending.map { list ->
        if (list.isEmpty()) {
            0f
        } else {
            val totalBudgeted = list.sumOf { it.budget.amount }
            val totalSpent = list.sumOf { it.currentSpending }
            if (totalBudgeted > 0) (totalSpent / totalBudgeted).toFloat() else 0f
        }
    }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5000),
        0f
    )

    fun createBudget(budget: Budget) {
        viewModelScope.launch {
            budgetRepository.insertBudget(budget)
        }
    }

    fun deleteBudget(budget: Budget) {
        viewModelScope.launch {
            budgetRepository.deleteBudget(budget)
        }
    }
}

data class BudgetWithSpending(
    val budget: Budget,
    val currentSpending: Double
)